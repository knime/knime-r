<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Use C-style String Formatting Commands</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for sprintf {base}"><tr><td>sprintf {base}</td><td align="right">R Documentation</td></tr></table>
<h2>Use C-style String Formatting Commands</h2>


<h3>Description</h3>

<p>
A wrapper for the C function <code>sprintf</code>, that returns a character
vector containing a formatted combination of text and variable values.
</p>


<h3>Usage</h3>

<pre>
sprintf(fmt, ...)
gettextf(fmt, ..., domain = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>fmt</code></td>
<td>
a character vector of format strings, each of up to 8192 bytes.</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
values to be passed into <code>fmt</code>.  Only logical,
integer, real and character vectors are supported, but some coercion
will be done: see the &lsquo;Details&rsquo; section.</td></tr>
<tr valign="top"><td><code>domain</code></td>
<td>
see <code><a href="gettext.html">gettext</a></code>.</td></tr>
</table>

<h3>Details</h3>

<p>
<code>sprintf</code> is a wrapper for the system <code>sprintf</code> C-library
function.  Attempts are made to check that the mode of the values
passed match the format supplied, and <font face="Courier New,Courier" color="#666666"><b>R</b></font>'s special values (<code>NA</code>,
<code>Inf</code>, <code>-Inf</code> and <code>NaN</code>) are handled correctly.
</p>
<p>
<code>gettextf</code> is a convenience function which provides C-style
string formatting with possible translation of the format string.
</p>
<p>
The arguments (including <code>fmt</code>) are recycled if possible a whole
number of times to the length of the longest, and then the formatting
is done in parallel.
</p>
<p>
The following is abstracted from Kernighan and Ritchie
(see References).  The string <code>fmt</code> contains normal characters,
which are passed through to the output string, and also conversion
specifications which operate on the arguments provided through
<code>...</code>.  The allowed conversion specifications start with a
<code>%</code> and end with one of the letters in the set
<code>difeEgGsxX%</code>.  These letters denote the following types:
</p>

<dl>
<dt><code>d, i, x, X</code></dt><dd>Integer value, <code>x</code> and <code>X</code>
being hexadecimal (using the same case for <code>a-f</code> as the code).
Numeric variables with exactly integer values will be coerced to
integer. Formats <code>d</code> and <code>i</code> can also be used for
logical variables, which will be converted to <code>0</code>, <code>1</code>
or <code>NA</code>.
</dd>
<dt><code>f</code></dt><dd>Double precision value, in decimal notation of the
form "[-]mmm.ddd".  The number of decimal places is specified by
the precision: the default is 6; a precision of 0 suppresses the
decimal point.  Non-finite values are converted to <code>NA</code>,
<code>NaN</code> or (perhaps a sign followed by) <code>Inf</code>.
</dd>
<dt><code>e, E</code></dt><dd>Double precision value, in decimal notation of the
form <code>[-]m.ddde[+-]xx</code> or <code>[-]m.dddE[+-]xx</code>.
</dd>
<dt><code>g, G</code></dt><dd>Double precision value, in <code>%e</code> or
<code>%E</code> format if the exponent is less than -4 or greater than or
equal to the precision, and <code>%f</code> format otherwise.
</dd>
<dt><code>s</code></dt><dd>Character string.   Character <code>NA</code>s are
converted to <code>"NA"</code>.
</dd>
<dt><code>%</code></dt><dd>Literal <code>%</code> (none of the extra formatting
characters given below are permitted in this case).
</dd>
</dl>
<p>
Conversion by <code><a href="character.html">as.character</a></code> is used for non-character
arguments with <code>s</code> and by <code><a href="double.html">as.double</a></code> for
non-double arguments with <code>f, e, E, g, G</code>.  NB: the length is
determined before conversion, so do not rely on the internal
coercion if this would change the length.  The coercion is done only
once, so if <code>length(fmt) &gt; 1</code> then all elements must expect the
same types of arguments. 
</p>
<p>
In addition, between the initial <code>%</code> and the terminating
conversion character there may be, in any order:
</p>

<dl>
<dt><code>m.n</code></dt><dd>Two numbers separated by a period, denoting the
field width (<code>m</code>) and the precision (<code>n</code>).</dd>
<dt><code>-</code></dt><dd>Left adjustment of converted argument in its field.</dd>
<dt><code>+</code></dt><dd>Always print number with sign: by default only
negative numbers are printed with a sign.</dd>
<dt>a space</dt><dd>Prefix a space if the first character is not a sign.</dd>
<dt><code>0</code></dt><dd>For numbers, pad to the field width with leading zeros.</dd>
</dl>
<p>
Further, immediately after <code>%</code> may come <code>1$</code> to <code>99$</code>
to refer to numbered argument: this allows arguments to be
referenced out of order and is mainly intended for translators of
error messages.  If this is done it is best if all formats are
numbered: if not the unnumbered ones process the arguments in order.
See the examples.  This notation allows arguments to be used more than
once, in which case they must be used as the same type (integer,
double or character).
</p>
<p>
A field width or precision (but not both) may be indicated by an
asterisk <code>*</code>: in this case an argument specifies the desired
number.  A negative field width is taken as a '-' flag followed by a
positive field width.  A negative precision is treated as if the
precision were omitted.  The argument should be integer, but a double
argument will be coerced to integer.
</p>
<p>
There is a limit of 8192 bytes on elements of <code>fmt</code> and also on
strings included by a <code>%s</code> conversion specification.
</p>
<p>
Field widths and precisions of <code>%s</code> conversions are interpreted
as bytes, not characters, as described in the C standard.
</p>
<p>
Character inputs with embedded nul bytes will be truncated at the first nul.
</p>


<h3>Value</h3>

<p>
A character vector of length that of the longest input.  If any
element of <code>fmt</code> or any character argument is declared as UTF-8,
the element of the result will be in UTF-8 and have the encoding
declared as UTF-8.  Otherwise it will be in the current locale's
encoding.</p>

<h3>Author(s)</h3>

<p>
Original code by Jonathan Rougier, <a href="mailto:J.C.Rougier@durham.ac.uk">J.C.Rougier@durham.ac.uk</a>.
</p>


<h3>References</h3>

<p>
Kernighan, B. W. and Ritchie, D. M. (1988)
<EM>The C Programming Language.</EM> Second edition, Prentice Hall.
describes the format options in table B-1 in the Appendix.
</p>


<h3>See Also</h3>

<p>
<code><a href="formatc.html">formatC</a></code> for a way of formatting vectors of numbers in a
similar fashion.
</p>
<p>
<code><a href="paste.html">paste</a></code> for another way of creating a vector combining
text and values.
</p>
<p>
<code><a href="gettext.html">gettext</a></code> for the mechanisms for the automated translation
of text.
</p>


<h3>Examples</h3>

<pre>
## be careful with the format: most things in R are floats
## only integer-valued reals get coerced to integer.

sprintf("%s is %f feet tall\n", "Sven", 7.1)      # OK
try(sprintf("%s is %i feet tall\n", "Sven", 7.1)) # not OK
try(sprintf("%s is %i feet tall\n", "Sven", 7))   # OK

## use a literal % :

sprintf("%.0f%% said yes (out of a sample of size %.0f)", 66.666, 3)

## various formats of pi :

sprintf("%f", pi)
sprintf("%.3f", pi)
sprintf("%1.0f", pi)
sprintf("%5.1f", pi)
sprintf("%05.1f", pi)
sprintf("%+f", pi)
sprintf("% f", pi)
sprintf("%-10f", pi) # left justified
sprintf("%e", pi)
sprintf("%E", pi)
sprintf("%g", pi)
sprintf("%g",   1e6 * pi) # -&gt; exponential
sprintf("%.9g", 1e6 * pi) # -&gt; "fixed"
sprintf("%G", 1e-6 * pi)

## no truncation:
sprintf("%1.f",101)

## re-use one argument three times, show difference between %x and %X
xx &lt;- sprintf("%1$d %1$x %1$X", 0:15)
xx &lt;- matrix(xx, dimnames=list(rep("", 16), "%d%x%X"))
noquote(format(xx, justify="right"))

## More sophisticated:

sprintf("min 10-char string '%10s'",
        c("a", "ABC", "and an even longer one"))

n &lt;- 1:18
sprintf(paste("e with %2d digits = %.",n,"g",sep=""), n, exp(1))

## Using arguments out of order
sprintf("second %2$1.0f, first %1$5.2f, third %3$1.0f", pi, 2, 3)

## Using asterisk for width or precision
sprintf("precision %.*f, width '%*.3f'", 3, pi, 8, pi)

## Asterisk and argument re-use, 'e' example reiterated:
sprintf("e with %1$2d digits = %2$.*1$g", n, exp(1))

## re-cycle arguments 
sprintf("%s %d", "test", 1:3)
</pre>



<hr><div align="center">[Package <em>base</em> version 2.7.2 <a href="00Index.html">Index]</a></div>

</body></html>
